# 1. Java 基础知识

## 编程语言

- 面向过程、面向对象、面向函数
- 静态类型、动态类型
- 编译执行、解释执行
- 有虚拟机、无虚拟机
- 有 GC、无 GC

Java 是一种面向对象、静态类型、编译执行、有 VM/GC 和运行时、跨平台的高级语言。

## Java、C++、Rust 的区别

C/C++ 完全相信而且惯着程序员，让大家自行管理内存，可以编写很自由的代码，但一不小心就会造成内存泄漏等问题，导致程序崩溃。

Java/Golang 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行时统一管理。在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是什么情况。内存使用有问题的时候，我们可以通过 JVM 来进行相关的分析诊断和调整。这也是本课程的目标。

Rust 语言选择既不相信程序员，也不惯着从程序员。让你在写代码的时候，必须清楚明白的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。但是这样会导致代码不利于人的理解，写代码很不自由，学习成本也很高。

## 字节码、类加载器、虚拟机

文件系统读取字节码文件，虚拟机通过类加载器生成对象实例。

# 2. Java 字节码技术

## 什么是字节码？

Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）实际上 Java 只使用了 200 左右的操作码，还有一些操作码则保留给调试操作。

根据指令的性质，主要分为四个大类：

1. 栈操作指令，包括与局部变量交互的指令
2. 程序流程控制指令
3. 对象操作指令，包括方法调用指令
4. 算数运算以及类型转换指令

## 生成字节码

```java
public class HelloByteCode {
  public static void main(String[] args) {
    jvm.HelloByteCode obj = new jvm.HelloByteCode();
  }
}
```

编译: javac HelloByteCode.java
查看字节码: javap -c HelloByteCode

## 最简单的字节码

结果如下所示：

```java
Compiled from "HelloByteCode.java"
public class HelloByteCode {
  public HelloByteCode();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #7                  // class HelloByteCode
       3: dup
       4: invokespecial #9                  // Method "<init>":()V
       7: astore_1
       8: return
}
```

LOCAL VARIABLE -> LOAD -> STACK
LOCAL VARIABLE <- STORE <- STACK

## 复杂点的例子

进一步： javap -c -verbose HelloByteCode

```java
public class HelloByteCode
  minor version: 0
  major version: 58
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #7                          // HelloByteCode
  super_class: #2                         // java/lang/Object
  interfaces: 0, fields: 0, methods: 2, attributes: 1
Constant pool:
   #1 = Methodref          #2.#3          // java/lang/Object."<init>":()V
   #2 = Class              #4             // java/lang/Object
   #3 = NameAndType        #5:#6          // "<init>":()V
   #4 = Utf8               java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Class              #8             // HelloByteCode
   #8 = Utf8               HelloByteCode
   #9 = Methodref          #7.#3          // HelloByteCode."<init>":()V
  #10 = Utf8               Code
  #11 = Utf8               LineNumberTable
  #12 = Utf8               main
  #13 = Utf8               ([Ljava/lang/String;)V
  #14 = Utf8               SourceFile
  #15 = Utf8               HelloByteCode.java
{
  public HelloByteCode();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 4: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #7                  // class HelloByteCode
         3: dup
         4: invokespecial #9                  // Method "<init>":()V
         7: astore_1
         8: return
      LineNumberTable:
        line 6: 0
        line 7: 8
}
SourceFile: "HelloByteCode.java"
```

## 字节码的运行时结构

JVM 是一台基于栈的计算机器。
每个线程都有一个独属于自己的线程栈（JVM Stack），用于存储栈帧（Frame）。
每一次方法调用，JVM 都会自动创建一个栈帧。
栈帧由操作数栈，局部变量数组以及一个 Class 引用组成。
Class 引用指向当前方法在运行时常量池中对应的 Class。

## 从助记符到二进制

```
0: new           #7                  // class HelloByteCode
3: dup
4: invokespecial #9                  // Method "<init>":()V
7: astore_1
8: return
```

|  0  |  1  |  2  |  3  |       4        |  5  |  6  |    7     |   8    |
| :-: | :-: | :-: | :-: | :------------: | :-: | :-: | :------: | :----: |
| new | 00  | 07  | dup | invoke special | 00  | 03  | astore_1 | return |

|  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| bb  | 00  | 07  | 59  | b7  | 00  | 03  | 4c  | b1  |

```
  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
00000000: CA FE BA BE 00 00 00 3A 00 10 0A 00 02 00 03 07    J~:>...:........
00000010: 00 04 0C 00 05 00 06 01 00 10 6A 61 76 61 2F 6C    ..........java/l
00000020: 61 6E 67 2F 4F 62 6A 65 63 74 01 00 06 3C 69 6E    ang/Object...<in
00000030: 69 74 3E 01 00 03 28 29 56 07 00 08 01 00 0D 48    it>...()V......H
00000040: 65 6C 6C 6F 42 79 74 65 43 6F 64 65 0A 00 07 00    elloByteCode....
00000050: 03 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E    ....Code...LineN
00000060: 75 6D 62 65 72 54 61 62 6C 65 01 00 04 6D 61 69    umberTable...mai
00000070: 6E 01 00 16 28 5B 4C 6A 61 76 61 2F 6C 61 6E 67    n...([Ljava/lang
00000080: 2F 53 74 72 69 6E 67 3B 29 56 01 00 0A 53 6F 75    /String;)V...Sou
00000090: 72 63 65 46 69 6C 65 01 00 12 48 65 6C 6C 6F 42    rceFile...HelloB
000000a0: 79 74 65 43 6F 64 65 2E 6A 61 76 61 00 21 00 07    yteCode.java.!..
000000b0: 00 02 00 00 00 00 00 02 00 01 00 05 00 06 00 01    ................
000000c0: 00 0A 00 00 00 1D 00 01 00 01 00 00 00 05 2A B7    ..............*7
000000d0: 00 01 B1 00 00 00 01 00 0B 00 00 00 06 00 01 00    ..1.............
000000e0: 00 00 04 00 09 00 0C 00 0D 00 01 00 0A 00 00 00    ................
000000f0: 25 00 02 00 02 00 00 00 09(BB 00 07 59 B7 00 09    %........;..Y7..
00000100: 4C B1)00 00 00 01 00 0B 00 00 00 0A 00 02 00 00    L1..............
00000110: 00 06 00 08 00 07 00 01 00 0E 00 00 00 02 00 0F    ................
```

## 四则运算的例子

```java
// 移动平均数
public class MovingAverage {
  private int count = 0;
  private double sum = 0.0D;
  public void submit(double value) {
    this.count ++;
    this.sum += value;
  }
  public double getAvg() {
    if (0 == this.count) {return sum;}
    return this.sum / this.count;
  }
}
```

```java
public class LocalVariableTest {
  public static void main(String[] args) {
    MovingAverage ma = new MovingAverage();
    int num1 = 1;
    int num2 = 2;
    ma.submit(num1);
    ma.submit(num2);
    double avg = ma.getAvg();
  }
}
```

## 数值处理与本地变量表

```java
Compiled from "LocalVariableTest.java"
public class LocalVariableTest {
  public LocalVariableTest();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #7                  // class MovingAverage
       3: dup
       4: invokespecial #9                  // Method MovingAverage."<init>":()V
       7: astore_1
       8: iconst_1
       9: istore_2
      10: iconst_2
      11: istore_3
      12: aload_1
      13: iload_2
      14: i2d
      15: invokevirtual #10                 // Method MovingAverage.submit:(D)V
      18: aload_1
      19: iload_3
      20: i2d
      21: invokevirtual #10                 // Method MovingAverage.submit:(D)V
      24: aload_1
      25: invokevirtual #14                 // Method MovingAverage.getAvg:()D
      28: dstore        4
      30: return
}
```

编译： javac -g:vars LocalVariableTest.java
查看字节码：javap -v LocalVariableTest

```java
LocalVariableTable:
  Start  Length  Slot  Name   Signature
      0      31     0  args   [Ljava/lang/String;
      8      23     1    ma   LMovingAverage;
     10      21     2  num1   I
     12      19     3  num2   I
     30       1     4   avg   D
```

## 算数操作与类型转换

|        | add + | sub - | mult. \* | divide / | remainder % | negate -() |
| :----: | :---: | :---: | :------: | :------: | :---------: | :--------: |
|  int   | iadd  | isub  |   imul   |   idiv   |    irem     |    ineg    |
|  long  | ladd  | lsub  |   lmul   |   ldiv   |    lrem     |    lneg    |
| float  | fadd  | fsub  |   fmul   |   fdiv   |    frem     |    fneg    |
| double | dadd  | dsub  |   dmul   |   ddiv   |    drem     |    dneg    |

|        | int | long | float | double | byte | char | short |
| :----: | :-: | :--: | :---: | :----: | :--: | :--: | ----- |
|  int   |  -  | i2l  |  i2f  |  i2d   | i2b  | i2c  | i2s   |
|  long  | l2i |  -   |  l2f  |  l2d   |  -   |  -   | -     |
| float  | f2i | f2l  |   -   |  f2d   |  -   |  -   | -     |
| double | d2i | d2l  |  d2f  |   -    |  -   |  -   | -     |

## 一个完整的循环控制

```java
public class ForLoopTest {
  private static int[] numbers = {1, 6, 8};
  public static void main(String[] args) {
    MovingAverage ma = new MovingAverage();
    for (int number : numbers) {
      ma.submit(number);
    }
    double avg = ma.getAvg();
  }
}
```

```java
Compiled from "ForLoopTest.java"
public class ForLoopTest {
  public ForLoopTest();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #7                  // class MovingAverage
       3: dup
       4: invokespecial #9                  // Method MovingAverage."<init>":()V
       7: astore_1
       8: getstatic     #10                 // Field numbers:[I
      11: astore_2
      12: aload_2
      13: arraylength
      14: istore_3
      15: iconst_0
      16: istore        4
      18: iload         4
      20: iload_3
      21: if_icmpge     43
      24: aload_2
      25: iload         4
      27: iaload
      28: istore        5
      30: aload_1
      31: iload         5
      33: i2d
      34: invokevirtual #16                 // Method MovingAverage.submit:(D)V
      37: iinc          4, 1
      40: goto          18
      43: aload_1
      44: invokevirtual #20                 // Method MovingAverage.getAvg:()D
      47: dstore_2
      48: return

  static {};
    Code:
       0: iconst_3
       1: newarray       int
       3: dup
       4: iconst_0
       5: iconst_1
       6: iastore
       7: dup
       8: iconst_1
       9: bipush        6
      11: iastore
      12: dup
      13: iconst_2
      14: bipush        8
      16: iastore
      17: putstatic     #10                 // Field numbers:[I
      20: return
}
```

## 方法调用的指令

invokestatic, 顾名思义，这个指令用于调用某个类的静态方法，这是方法调用指令中最快的一个。

invokespecial, 用来调用构造函数，但也可以用于同一个类中的 private 方法，以及可见的超类方法。

invokevirtual, 如果是具体类型的目标对象，invokevirtual 用于调用公共，受保护和 package 级的私有方法。

invokeinterface, 当通过接口引用来调用方法时，将会编译为 invokeinterface 指令。

invokedynamic, JDK7 新增加的指令，是实现“动态类型语言”（Dynamically Typed Language）支持而进行的升级改进，同时也是 JDK8 以后支持 lambda 表达式的实现基础。

## 一个动态例子

```java
public class Demo {
  public static void foo() {
    int a = 1;
    int b = 2;
    int c = (a + b) * 5;
  }
}
```

foo()代码

| 偏移量 | 字节码 |  助记符  |
| :----: | :----: | :------: |
|   0    |   04   | iconst_1 |
|   1    |   3B   | istore_0 |
|   2    |   05   | iconst_2 |
|   3    |   3C   | istore_1 |
|   4    |   1A   | iload_0  |
|   5    |   1B   | iload_1  |
|   6    |   60   |   iadd   |
|   7    |   08   | iconst_5 |
|   8    |   68   |   imul   |
|   9    |   3D   | istore_2 |
|   A    |   B1   |  return  |

# 3. JVM 类加载器

## 类的生命周期

1. 加载（Loading）: 找 Class 文件
2. 验证（Verification）: 验证格式、依赖
3. 准备（Preparation）: 静态字段、方法表
4. 解析（Resolution）: 符号解析为引用
5. 初始化（Initialization）: 构造器、静态变量赋值、静态代码块
6. 使用（Using）
7. 卸载（Unloading）

## 类的加载时机

1. 当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 所在的类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一个类的时候要初始化；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

## 不会初始化（可能会加载）

1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
2. 定义对象数组，不会触发该类的初始化。
3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
4. 通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始化。
5. 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
   Class.forName("jvm.Hello")默认会加载 Hello 类
6. 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载了，但是不初始化）。

## 三类加载器

1. 启动类加载器（BootstrapClassLoader）
2. 扩展类加载器（ExtClassLoader）
3. 应用类加载器（AppClassLoader）

加载器特点：

1. 双亲委托
2. 负责依赖
3. 缓存加载

## 显示当前 ClassLoader 加载了哪些 Jar?

```java
public class JvmClassLoaderPrintPath {
  public static void main(String[] args) {
    // 启动类加载器
    URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
    System.out.println("启动类加载器");
    for (URL url : urls) {
      System.out.println(" ==> " + url.toExternalForm());
    }

    // 扩展类加载器
    printClassLoader("扩展类加载器", jvm.JvmClassLoaderPrintPath.class.getClassLoader().getParent());

    // 应用类加载器
    printClassLoader("应用类加载器", jvm.JvmClassLoaderPrintPath.class.getClassLoader());
  }

  public static void printClassLoader(String name, ClassLoader CL) {
    if (CL != null) {
      System.out.println(name + " ClassLoader -> " + CL.toString());
      printURLForClassLoader(CL);
    } else {
      System.out.println(name + " ClassLoader -> null");
    }
  }

  public static void printURLForClassLoader(ClassLoader CL) {
    Object ucp = insightField(CL, "ucp");
    Object path = insightField(ucp, "path");
    ArrayList ps = (ArrayList) path;
    for (Object p : ps) {
      System.out.println(" ==> " + p.toString());
    }
  }

  private static Object insightField(Object obj, String fName) {
    try {
      Field f = null;
      if (obj instanceof URLClassLoader) {
        f = URLClassLoader.class.getDeclaredField(fName);
      } else {
        f = obj.getClass().getDeclaredField(fName);
      }
      f.setAccessible(true);
      return f.get(obj);
    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }
  }
}
```

```
启动类加载器
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/resources.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/rt.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/sunrsasign.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/jsse.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/jce.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/charsets.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/jfr.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/classes
扩展类加载器 ClassLoader -> sun.misc.Launcher$ExtClassLoader@45ee12a7
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/sunec.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/nashorn.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/cldrdata.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/jfxrt.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/dnsns.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/localedata.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/jaccess.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/zipfs.jar
应用类加载器 ClassLoader -> sun.misc.Launcher$AppClassLoader@7f31245a
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/charsets.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/deploy.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/cldrdata.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/dnsns.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/jaccess.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/jfxrt.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/localedata.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/nashorn.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/sunec.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/ext/zipfs.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/javaws.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/jce.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/jfr.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/jfxswt.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/jsse.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/management-agent.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/plugin.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/resources.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/rt.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/lib/ant-javafx.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/lib/dt.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/lib/javafx-mx.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/lib/jconsole.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/lib/packager.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/lib/sa-jdi.jar
 ==> file:/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/lib/tools.jar
 ==> file:/Users/zhushuangquan/Codes/GitHub/coderZsq.practice.server/study-notes/geek-university/Java%e8%bf%9b%e9%98%b6%e8%ae%ad%e7%bb%83%e8%90%a5%20%7c%20%e7%ac%ac01%e5%91%a8%20%7c%20JVM%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af/out/production/jvm/
```

## 自定义 ClassLoader
