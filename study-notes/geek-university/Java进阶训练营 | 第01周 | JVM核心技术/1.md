# 1. Java 基础知识

## 编程语言

- 面向过程、面向对象、面向函数
- 静态类型、动态类型
- 编译执行、解释执行
- 有虚拟机、无虚拟机
- 有 GC、无 GC

Java 是一种面向对象、静态类型、编译执行、有 VM/GC 和运行时、跨平台的高级语言。

## Java、C++、Rust 的区别

C/C++ 完全相信而且惯着程序员，让大家自行管理内存，可以编写很自由的代码，但一不小心就会造成内存泄漏等问题，导致程序崩溃。

Java/Golang 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行时统一管理。在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是什么情况。内存使用有问题的时候，我们可以通过 JVM 来进行相关的分析诊断和调整。这也是本课程的目标。

Rust 语言选择既不相信程序员，也不惯着从程序员。让你在写代码的时候，必须清楚明白的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。但是这样会导致代码不利于人的理解，写代码很不自由，学习成本也很高。

## 字节码、类加载器、虚拟机

文件系统读取字节码文件，虚拟机通过类加载器生成对象实例。

# 2. Java 字节码技术

## 什么是字节码？

Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）实际上 Java 只使用了 200 左右的操作码，还有一些操作码则保留给调试操作。

根据指令的性质，主要分为四个大类：

1. 栈操作指令，包括与局部变量交互的指令
2. 程序流程控制指令
3. 对象操作指令，包括方法调用指令
4. 算数运算以及类型转换指令

## 生成字节码

```java
public class HelloByteCode {
  public static void main(String[] args) {
    HelloByteCode obj = new HelloByteCode();
  }
}
```

编译: javac HelloByteCode.java
查看字节码: javap -c HelloByteCode

## 最简单的字节码

结果如下所示：

```java
Compiled from "HelloByteCode.java"
public class HelloByteCode {
  public HelloByteCode();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #7                  // class HelloByteCode
       3: dup
       4: invokespecial #9                  // Method "<init>":()V
       7: astore_1
       8: return
}
```

LOCAL VARIABLE -> LOAD -> STACK
LOCAL VARIABLE <- STORE <- STACK

## 复杂点的例子

进一步： javap -c -verbose HelloByteCode

```java
public class HelloByteCode
  minor version: 0
  major version: 58
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #7                          // HelloByteCode
  super_class: #2                         // java/lang/Object
  interfaces: 0, fields: 0, methods: 2, attributes: 1
Constant pool:
   #1 = Methodref          #2.#3          // java/lang/Object."<init>":()V
   #2 = Class              #4             // java/lang/Object
   #3 = NameAndType        #5:#6          // "<init>":()V
   #4 = Utf8               java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Class              #8             // HelloByteCode
   #8 = Utf8               HelloByteCode
   #9 = Methodref          #7.#3          // HelloByteCode."<init>":()V
  #10 = Utf8               Code
  #11 = Utf8               LineNumberTable
  #12 = Utf8               main
  #13 = Utf8               ([Ljava/lang/String;)V
  #14 = Utf8               SourceFile
  #15 = Utf8               HelloByteCode.java
{
  public HelloByteCode();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 4: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #7                  // class HelloByteCode
         3: dup
         4: invokespecial #9                  // Method "<init>":()V
         7: astore_1
         8: return
      LineNumberTable:
        line 6: 0
        line 7: 8
}
SourceFile: "HelloByteCode.java"
```

## 字节码的运行时结构

JVM 是一台基于栈的计算机器。
每个线程都有一个独属于自己的线程栈（JVM Stack），用于存储栈帧（Frame）。
每一次方法调用，JVM 都会自动创建一个栈帧。
栈帧由操作数栈，局部变量数组以及一个 Class 引用组成。
Class 引用指向当前方法在运行时常量池中对应的 Class。

## 从助记符到二进制

```
       0: new           #7                  // class HelloByteCode
       3: dup
       4: invokespecial #9                  // Method "<init>":()V
       7: astore_1
       8: return
```

```
new 00 07 dup
```

```
  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
00000000: CA FE BA BE 00 00 00 3A 00 10 0A 00 02 00 03 07    J~:>...:........
00000010: 00 04 0C 00 05 00 06 01 00 10 6A 61 76 61 2F 6C    ..........java/l
00000020: 61 6E 67 2F 4F 62 6A 65 63 74 01 00 06 3C 69 6E    ang/Object...<in
00000030: 69 74 3E 01 00 03 28 29 56 07 00 08 01 00 0D 48    it>...()V......H
00000040: 65 6C 6C 6F 42 79 74 65 43 6F 64 65 0A 00 07 00    elloByteCode....
00000050: 03 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E    ....Code...LineN
00000060: 75 6D 62 65 72 54 61 62 6C 65 01 00 04 6D 61 69    umberTable...mai
00000070: 6E 01 00 16 28 5B 4C 6A 61 76 61 2F 6C 61 6E 67    n...([Ljava/lang
00000080: 2F 53 74 72 69 6E 67 3B 29 56 01 00 0A 53 6F 75    /String;)V...Sou
00000090: 72 63 65 46 69 6C 65 01 00 12 48 65 6C 6C 6F 42    rceFile...HelloB
000000a0: 79 74 65 43 6F 64 65 2E 6A 61 76 61 00 21 00 07    yteCode.java.!..
000000b0: 00 02 00 00 00 00 00 02 00 01 00 05 00 06 00 01    ................
000000c0: 00 0A 00 00 00 1D 00 01 00 01 00 00 00 05 2A B7    ..............*7
000000d0: 00 01 B1 00 00 00 01 00 0B 00 00 00 06 00 01 00    ..1.............
000000e0: 00 00 04 00 09 00 0C 00 0D 00 01 00 0A 00 00 00    ................
000000f0: 25 00 02 00 02 00 00 00 09(BB 00 07 59 B7 00 09    %........;..Y7..
00000100: 4C B1)00 00 00 01 00 0B 00 00 00 0A 00 02 00 00    L1..............
00000110: 00 06 00 08 00 07 00 01 00 0E 00 00 00 02 00 0F    ................
```

## 四则运算的例子

```java
// 移动平均数
public class MovingAverage {
  private int count = 0;
  private double sum = 0.0D;
  public void submit(double value) {
    this.count ++;
    this.sum += value;
  }
  public double getAvg() {
    if (0 == this.count) {return sum;}
    return this.sum / this.count;
  }
}
```

```java
public class LocalVariableTest {
  public static void main(String[] args) {
    MovingAverage ma = new MovingAverage();
    int num1 = 1;
    int num2 = 2;
    ma.submit(num1);
    ma.submit(num2);
    double avg = ma.getAvg();
  }
}
```

## 数值处理与本地变量表

```java
Compiled from "LocalVariableTest.java"
public class LocalVariableTest {
  public LocalVariableTest();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #7                  // class MovingAverage
       3: dup
       4: invokespecial #9                  // Method MovingAverage."<init>":()V
       7: astore_1
       8: iconst_1
       9: istore_2
      10: iconst_2
      11: istore_3
      12: aload_1
      13: iload_2
      14: i2d
      15: invokevirtual #10                 // Method MovingAverage.submit:(D)V
      18: aload_1
      19: iload_3
      20: i2d
      21: invokevirtual #10                 // Method MovingAverage.submit:(D)V
      24: aload_1
      25: invokevirtual #14                 // Method MovingAverage.getAvg:()D
      28: dstore        4
      30: return
}
```

javac -g:vars LocalVariableTest.java
javap -v LocalVariableTest

```java
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      31     0  args   [Ljava/lang/String;
            8      23     1    ma   LMovingAverage;
           10      21     2  num1   I
           12      19     3  num2   I
           30       1     4   avg   D
}
```
